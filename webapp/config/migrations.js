// Database migration system for versioned schema changes
const fs = require('fs');
const path = require('path');
const { createLogger, logDatabaseOperation } = require('./logger');

const logger = createLogger();

// Migration utilities
const createMigrationsTable = async (db) => {
  const query = `
    CREATE TABLE IF NOT EXISTS migrations (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      version TEXT UNIQUE NOT NULL,
      name TEXT NOT NULL,
      executed_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      execution_time_ms INTEGER,
      checksum TEXT
    )
  `;
  
  await db.query(query);
  logger.info('Migrations table ensured');
};

const calculateChecksum = (migrationContent) => {
  const crypto = require('crypto');
  return crypto.createHash('md5').update(migrationContent).digest('hex');
};

const getMigrationFiles = (migrationsDir) => {
  if (!fs.existsSync(migrationsDir)) {
    fs.mkdirSync(migrationsDir, { recursive: true });
    logger.info('Created migrations directory', { path: migrationsDir });
  }
  
  const files = fs.readdirSync(migrationsDir)
    .filter(file => file.endsWith('.js'))
    .sort(); // Ensure proper order\n  \n  return files.map(file => {\n    const filePath = path.join(migrationsDir, file);\n    const content = fs.readFileSync(filePath, 'utf8');\n    \n    // Extract version from filename (format: YYYYMMDDHHMMSS_migration_name.js)\n    const versionMatch = file.match(/^(\\d{14})_(.+)\\.js$/);\n    if (!versionMatch) {\n      throw new Error(`Invalid migration filename format: ${file}. Expected: YYYYMMDDHHMMSS_name.js`);\n    }\n    \n    return {\n      version: versionMatch[1],\n      name: versionMatch[2],\n      filename: file,\n      path: filePath,\n      content,\n      checksum: calculateChecksum(content)\n    };\n  });\n};\n\nconst getExecutedMigrations = async (db) => {\n  try {\n    const migrations = await db.query(\n      'SELECT version, name, executed_at, checksum FROM migrations ORDER BY version'\n    );\n    return migrations;\n  } catch (error) {\n    // Table might not exist yet\n    return [];\n  }\n};\n\nconst executeMigration = async (db, migration) => {\n  const startTime = Date.now();\n  \n  logger.info('Executing migration', {\n    version: migration.version,\n    name: migration.name\n  });\n  \n  try {\n    // Load and execute the migration\n    const migrationModule = require(migration.path);\n    \n    if (typeof migrationModule.up !== 'function') {\n      throw new Error(`Migration ${migration.filename} must export an 'up' function`);\n    }\n    \n    // Execute migration in a transaction\n    await db.transaction(async () => {\n      await migrationModule.up(db);\n      \n      // Record migration execution\n      const executionTime = Date.now() - startTime;\n      await db.run(\n        'INSERT INTO migrations (version, name, execution_time_ms, checksum) VALUES (?, ?, ?, ?)',\n        [migration.version, migration.name, executionTime, migration.checksum]\n      );\n    });\n    \n    const executionTime = Date.now() - startTime;\n    logger.info('Migration executed successfully', {\n      version: migration.version,\n      name: migration.name,\n      executionTime: `${executionTime}ms`\n    });\n    \n    return { success: true, executionTime };\n  } catch (error) {\n    logger.error('Migration execution failed', {\n      version: migration.version,\n      name: migration.name,\n      error: error.message\n    });\n    \n    throw error;\n  }\n};\n\nconst rollbackMigration = async (db, migration) => {\n  const startTime = Date.now();\n  \n  logger.info('Rolling back migration', {\n    version: migration.version,\n    name: migration.name\n  });\n  \n  try {\n    // Load the migration\n    const migrationModule = require(migration.path);\n    \n    if (typeof migrationModule.down !== 'function') {\n      throw new Error(`Migration ${migration.filename} must export a 'down' function for rollback`);\n    }\n    \n    // Execute rollback in a transaction\n    await db.transaction(async () => {\n      await migrationModule.down(db);\n      \n      // Remove migration record\n      await db.run(\n        'DELETE FROM migrations WHERE version = ?',\n        [migration.version]\n      );\n    });\n    \n    const executionTime = Date.now() - startTime;\n    logger.info('Migration rolled back successfully', {\n      version: migration.version,\n      name: migration.name,\n      executionTime: `${executionTime}ms`\n    });\n    \n    return { success: true, executionTime };\n  } catch (error) {\n    logger.error('Migration rollback failed', {\n      version: migration.version,\n      name: migration.name,\n      error: error.message\n    });\n    \n    throw error;\n  }\n};\n\nconst validateMigrations = (availableMigrations, executedMigrations) => {\n  const errors = [];\n  \n  // Check for checksum mismatches\n  for (const executed of executedMigrations) {\n    const available = availableMigrations.find(m => m.version === executed.version);\n    \n    if (!available) {\n      errors.push(`Executed migration ${executed.version} (${executed.name}) not found in migration files`);\n      continue;\n    }\n    \n    if (available.checksum !== executed.checksum) {\n      errors.push(`Migration ${executed.version} (${executed.name}) has been modified since execution`);\n    }\n  }\n  \n  return errors;\n};\n\n// Main migration functions\nconst runMigrations = async (db, options = {}) => {\n  const migrationsDir = options.migrationsDir || path.join(process.cwd(), 'migrations');\n  const dryRun = options.dryRun || false;\n  \n  logger.info('Starting database migrations', { migrationsDir, dryRun });\n  \n  try {\n    // Ensure migrations table exists\n    await createMigrationsTable(db);\n    \n    // Get available and executed migrations\n    const availableMigrations = getMigrationFiles(migrationsDir);\n    const executedMigrations = await getExecutedMigrations(db);\n    \n    // Validate migrations\n    const validationErrors = validateMigrations(availableMigrations, executedMigrations);\n    if (validationErrors.length > 0) {\n      throw new Error(`Migration validation failed:\\n${validationErrors.join('\\n')}`);\n    }\n    \n    // Find pending migrations\n    const executedVersions = new Set(executedMigrations.map(m => m.version));\n    const pendingMigrations = availableMigrations.filter(m => !executedVersions.has(m.version));\n    \n    if (pendingMigrations.length === 0) {\n      logger.info('No pending migrations');\n      return { executed: 0, pending: 0 };\n    }\n    \n    logger.info(`Found ${pendingMigrations.length} pending migrations`);\n    \n    if (dryRun) {\n      logger.info('Dry run - migrations that would be executed:');\n      pendingMigrations.forEach(m => {\n        logger.info(`  ${m.version} - ${m.name}`);\n      });\n      return { executed: 0, pending: pendingMigrations.length };\n    }\n    \n    // Execute pending migrations\n    let executedCount = 0;\n    for (const migration of pendingMigrations) {\n      await executeMigration(db, migration);\n      executedCount++;\n    }\n    \n    logger.info('All migrations executed successfully', {\n      executed: executedCount,\n      total: availableMigrations.length\n    });\n    \n    return { executed: executedCount, pending: 0 };\n  } catch (error) {\n    logger.error('Migration process failed', { error: error.message });\n    throw error;\n  }\n};\n\nconst rollbackMigrations = async (db, options = {}) => {\n  const migrationsDir = options.migrationsDir || path.join(process.cwd(), 'migrations');\n  const steps = options.steps || 1;\n  const dryRun = options.dryRun || false;\n  \n  logger.info('Starting migration rollback', { steps, dryRun });\n  \n  try {\n    // Get executed migrations (in reverse order for rollback)\n    const executedMigrations = await getExecutedMigrations(db);\n    const toRollback = executedMigrations.slice(-steps).reverse();\n    \n    if (toRollback.length === 0) {\n      logger.info('No migrations to rollback');\n      return { rolledBack: 0 };\n    }\n    \n    // Get migration files for rollback execution\n    const availableMigrations = getMigrationFiles(migrationsDir);\n    const migrationsToRollback = toRollback.map(executed => {\n      const available = availableMigrations.find(m => m.version === executed.version);\n      if (!available) {\n        throw new Error(`Migration file not found for rollback: ${executed.version}`);\n      }\n      return available;\n    });\n    \n    if (dryRun) {\n      logger.info('Dry run - migrations that would be rolled back:');\n      migrationsToRollback.forEach(m => {\n        logger.info(`  ${m.version} - ${m.name}`);\n      });\n      return { rolledBack: 0 };\n    }\n    \n    // Execute rollbacks\n    let rolledBackCount = 0;\n    for (const migration of migrationsToRollback) {\n      await rollbackMigration(db, migration);\n      rolledBackCount++;\n    }\n    \n    logger.info('Rollback completed successfully', {\n      rolledBack: rolledBackCount\n    });\n    \n    return { rolledBack: rolledBackCount };\n  } catch (error) {\n    logger.error('Rollback process failed', { error: error.message });\n    throw error;\n  }\n};\n\nconst getMigrationStatus = async (db, options = {}) => {\n  const migrationsDir = options.migrationsDir || path.join(process.cwd(), 'migrations');\n  \n  try {\n    await createMigrationsTable(db);\n    \n    const availableMigrations = getMigrationFiles(migrationsDir);\n    const executedMigrations = await getExecutedMigrations(db);\n    \n    const executedVersions = new Set(executedMigrations.map(m => m.version));\n    const pendingMigrations = availableMigrations.filter(m => !executedVersions.has(m.version));\n    \n    return {\n      total: availableMigrations.length,\n      executed: executedMigrations.length,\n      pending: pendingMigrations.length,\n      availableMigrations,\n      executedMigrations,\n      pendingMigrations\n    };\n  } catch (error) {\n    logger.error('Failed to get migration status', { error: error.message });\n    throw error;\n  }\n};\n\n// Migration file generator\nconst generateMigration = (name, migrationsDir) => {\n  const timestamp = new Date().toISOString().replace(/[-:T.]/g, '').slice(0, 14);\n  const filename = `${timestamp}_${name.replace(/\\s+/g, '_').toLowerCase()}.js`;\n  const filepath = path.join(migrationsDir || path.join(process.cwd(), 'migrations'), filename);\n  \n  const template = `// Migration: ${name}\n// Created: ${new Date().toISOString()}\n\nmodule.exports = {\n  async up(db) {\n    // TODO: Implement migration\n    // Example:\n    // await db.query('ALTER TABLE bookmarks ADD COLUMN new_field TEXT');\n  },\n  \n  async down(db) {\n    // TODO: Implement rollback\n    // Example:\n    // await db.query('ALTER TABLE bookmarks DROP COLUMN new_field');\n  }\n};\n`;\n  \n  // Ensure migrations directory exists\n  const dir = path.dirname(filepath);\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true });\n  }\n  \n  fs.writeFileSync(filepath, template);\n  \n  logger.info('Migration file created', {\n    name,\n    filename,\n    path: filepath\n  });\n  \n  return { filename, path: filepath };\n};\n\nmodule.exports = {\n  runMigrations,\n  rollbackMigrations,\n  getMigrationStatus,\n  generateMigration,\n  createMigrationsTable\n};