// Comprehensive security middleware
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');
const ExpressBrute = require('express-brute');
const SQLiteStore = require('express-brute-sqlite');
const { body, validationResult } = require('express-validator');
const { logSecurityEvent } = require('../config/logger');
const { createLogger } = require('../config/logger');

const logger = createLogger();

// Security configuration
const SALT_ROUNDS = 12;
const JWT_EXPIRY = '24h';
const MAX_LOGIN_ATTEMPTS = 5;
const LOCKOUT_DURATION = 15 * 60 * 1000; // 15 minutes

// Brute force protection store
const bruteForcStore = new SQLiteStore('./data/brute-force.db');
const bruteForce = new ExpressBrute(bruteForcStore, {
  freeRetries: MAX_LOGIN_ATTEMPTS,
  minWait: 1000, // 1 second
  maxWait: LOCKOUT_DURATION,
  lifetime: LOCKOUT_DURATION,
  failCallback: (req, res, next, nextValidRequestDate) => {
    const ip = req.ip;
    const timeRemaining = Math.ceil((nextValidRequestDate - Date.now()) / 1000);
    
    logSecurityEvent(logger, 'brute_force_attempt', {
      ip,
      url: req.originalUrl,
      userAgent: req.get('User-Agent'),
      timeRemaining
    }, 'error');
    
    res.status(429).json({
      success: false,
      message: 'Too many failed attempts. Please try again later.',
      retryAfter: timeRemaining\n    });\n  }\n});\n\n// Password utilities\nconst hashPassword = async (password) => {\n  return await bcrypt.hash(password, SALT_ROUNDS);\n};\n\nconst verifyPassword = async (password, hash) => {\n  return await bcrypt.compare(password, hash);\n};\n\n// JWT utilities\nconst generateToken = (payload, secret = process.env.SESSION_SECRET) => {\n  return jwt.sign(payload, secret, { expiresIn: JWT_EXPIRY });\n};\n\nconst verifyToken = (token, secret = process.env.SESSION_SECRET) => {\n  try {\n    return jwt.verify(token, secret);\n  } catch (error) {\n    return null;\n  }\n};\n\n// Input validation schemas\nconst passwordValidation = [\n  body('password')\n    .isLength({ min: 8 })\n    .withMessage('Password must be at least 8 characters long')\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)\n    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character')\n];\n\nconst emailValidation = [\n  body('email')\n    .isEmail()\n    .withMessage('Valid email is required')\n    .normalizeEmail()\n    .isLength({ max: 255 })\n    .withMessage('Email is too long')\n];\n\nconst userValidation = [\n  ...emailValidation,\n  ...passwordValidation,\n  body('name')\n    .trim()\n    .isLength({ min: 2, max: 100 })\n    .withMessage('Name must be between 2 and 100 characters')\n    .matches(/^[a-zA-Z\\s-']+$/)\n    .withMessage('Name can only contain letters, spaces, hyphens, and apostrophes')\n];\n\nconst loginValidation = [\n  ...emailValidation,\n  body('password')\n    .notEmpty()\n    .withMessage('Password is required')\n];\n\n// Security middleware functions\nconst requireAuth = async (req, res, next) => {\n  try {\n    const token = req.header('Authorization')?.replace('Bearer ', '') || \n                  req.header('X-Auth-Token') ||\n                  req.cookies?.authToken;\n    \n    if (!token) {\n      return res.status(401).json({\n        success: false,\n        message: 'Access denied. No token provided.'\n      });\n    }\n    \n    const decoded = verifyToken(token);\n    if (!decoded) {\n      logSecurityEvent(logger, 'invalid_token', {\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        url: req.originalUrl\n      });\n      \n      return res.status(401).json({\n        success: false,\n        message: 'Access denied. Invalid token.'\n      });\n    }\n    \n    // Check if user still exists and is active\n    const db = require('../config/database');\n    const users = await db.query(\n      'SELECT id, email, name, is_active FROM users WHERE id = ? AND is_active = TRUE',\n      [decoded.userId]\n    );\n    \n    if (users.length === 0) {\n      logSecurityEvent(logger, 'user_not_found', {\n        userId: decoded.userId,\n        ip: req.ip,\n        userAgent: req.get('User-Agent')\n      });\n      \n      return res.status(401).json({\n        success: false,\n        message: 'Access denied. User not found or inactive.'\n      });\n    }\n    \n    req.user = users[0];\n    next();\n  } catch (error) {\n    logSecurityEvent(logger, 'auth_error', {\n      error: error.message,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    }, 'error');\n    \n    res.status(500).json({\n      success: false,\n      message: 'Authentication error'\n    });\n  }\n};\n\nconst optionalAuth = async (req, res, next) => {\n  try {\n    const token = req.header('Authorization')?.replace('Bearer ', '') || \n                  req.header('X-Auth-Token') ||\n                  req.cookies?.authToken;\n    \n    if (token) {\n      const decoded = verifyToken(token);\n      if (decoded) {\n        const db = require('../config/database');\n        const users = await db.query(\n          'SELECT id, email, name, is_active FROM users WHERE id = ? AND is_active = TRUE',\n          [decoded.userId]\n        );\n        \n        if (users.length > 0) {\n          req.user = users[0];\n        }\n      }\n    }\n    \n    next();\n  } catch (error) {\n    // Don't fail for optional auth, just continue without user\n    next();\n  }\n};\n\n// Rate limiting configurations\nconst createRateLimit = (windowMs, max, message) => {\n  return rateLimit({\n    windowMs,\n    max,\n    message: {\n      success: false,\n      message\n    },\n    standardHeaders: true,\n    legacyHeaders: false,\n    handler: (req, res) => {\n      logSecurityEvent(logger, 'rate_limit_exceeded', {\n        ip: req.ip,\n        url: req.originalUrl,\n        userAgent: req.get('User-Agent')\n      });\n      \n      res.status(429).json({\n        success: false,\n        message\n      });\n    }\n  });\n};\n\n// Specific rate limiters\nconst authRateLimit = createRateLimit(\n  15 * 60 * 1000, // 15 minutes\n  10, // attempts per window\n  'Too many authentication attempts. Please try again later.'\n);\n\nconst apiRateLimit = createRateLimit(\n  15 * 60 * 1000, // 15 minutes\n  1000, // requests per window\n  'Too many API requests. Please try again later.'\n);\n\nconst strictRateLimit = createRateLimit(\n  15 * 60 * 1000, // 15 minutes\n  100, // requests per window\n  'Rate limit exceeded for this endpoint.'\n);\n\n// Input sanitization\nconst sanitizeInput = (req, res, next) => {\n  const sanitizeString = (str) => {\n    if (typeof str !== 'string') return str;\n    \n    // Remove null bytes\n    str = str.replace(/\\0/g, '');\n    \n    // Trim whitespace\n    str = str.trim();\n    \n    // Basic HTML encoding for output (prevent XSS)\n    str = str.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    \n    return str;\n  };\n  \n  const sanitizeObject = (obj) => {\n    if (obj === null || typeof obj !== 'object') return obj;\n    \n    if (Array.isArray(obj)) {\n      return obj.map(sanitizeObject);\n    }\n    \n    const sanitized = {};\n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === 'string') {\n        sanitized[key] = sanitizeString(value);\n      } else if (typeof value === 'object') {\n        sanitized[key] = sanitizeObject(value);\n      } else {\n        sanitized[key] = value;\n      }\n    }\n    return sanitized;\n  };\n  \n  req.body = sanitizeObject(req.body);\n  req.query = sanitizeObject(req.query);\n  req.params = sanitizeObject(req.params);\n  \n  next();\n};\n\n// Validation error handler\nconst handleValidationErrors = (req, res, next) => {\n  const errors = validationResult(req);\n  \n  if (!errors.isEmpty()) {\n    logSecurityEvent(logger, 'validation_error', {\n      errors: errors.array(),\n      ip: req.ip,\n      url: req.originalUrl,\n      body: req.body\n    });\n    \n    return res.status(400).json({\n      success: false,\n      message: 'Validation failed',\n      errors: errors.array()\n    });\n  }\n  \n  next();\n};\n\n// Content Security Policy\nconst cspDirectives = {\n  defaultSrc: [\"'self'\"],\n  scriptSrc: [\"'self'\", \"'unsafe-inline'\"],\n  styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n  imgSrc: [\"'self'\", \"data:\", \"https:\"],\n  fontSrc: [\"'self'\", \"https:\"],\n  connectSrc: [\"'self'\"],\n  mediaSrc: [\"'self'\"],\n  objectSrc: [\"'none'\"],\n  childSrc: [\"'none'\"],\n  frameAncestors: [\"'none'\"],\n  baseUri: [\"'self'\"],\n  formAction: [\"'self'\"]\n};\n\n// Security headers middleware\nconst securityHeaders = (req, res, next) => {\n  // HSTS\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');\n  \n  // XSS Protection\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  \n  // Content Type Options\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // Frame Options\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // Referrer Policy\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  \n  // Permissions Policy\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n  \n  next();\n};\n\n// CSRF protection (basic implementation)\nconst csrfProtection = (req, res, next) => {\n  // Skip CSRF for GET requests and API authentication\n  if (req.method === 'GET' || req.header('Authorization')) {\n    return next();\n  }\n  \n  const token = req.header('X-CSRF-Token') || req.body._csrf;\n  const sessionToken = req.session?.csrfToken;\n  \n  if (!token || !sessionToken || token !== sessionToken) {\n    logSecurityEvent(logger, 'csrf_violation', {\n      ip: req.ip,\n      url: req.originalUrl,\n      userAgent: req.get('User-Agent'),\n      providedToken: !!token,\n      sessionToken: !!sessionToken\n    });\n    \n    return res.status(403).json({\n      success: false,\n      message: 'CSRF token validation failed'\n    });\n  }\n  \n  next();\n};\n\n// Generate CSRF token\nconst generateCSRFToken = () => {\n  const crypto = require('crypto');\n  return crypto.randomBytes(32).toString('hex');\n};\n\nmodule.exports = {\n  // Authentication\n  requireAuth,\n  optionalAuth,\n  \n  // Password utilities\n  hashPassword,\n  verifyPassword,\n  \n  // JWT utilities\n  generateToken,\n  verifyToken,\n  \n  // Validation schemas\n  passwordValidation,\n  emailValidation,\n  userValidation,\n  loginValidation,\n  \n  // Rate limiting\n  authRateLimit,\n  apiRateLimit,\n  strictRateLimit,\n  bruteForce,\n  \n  // Security middleware\n  sanitizeInput,\n  handleValidationErrors,\n  securityHeaders,\n  csrfProtection,\n  \n  // Utilities\n  generateCSRFToken,\n  cspDirectives\n};